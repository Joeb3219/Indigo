// Written by Joseph Boyle
// A compiler written in Indigo

// Here we reserve some constants and other data used in the compiler.
// We reserve the first 1024 (0x0 thru 0x500) registers for the compiler's variables.
0x0 0x1 0x0 0x500 0xa // Register 1 contains the number of registers reserved for compiler use.
0x0 0x0 0x0 0x1 0x09 0xa // Register 0 contains the next available register for public use, which happens to be the value of register 1.
0x0 0x3 0x0 0x300 0xa // Register 3 contains the beginning register for where function arguments get stored
0x0 0x4 0x0 0x0 0xa // Register 4 contains the number of argument registers already in use.
0x0 0x5 0x0 0x100 0xa // Register 5 contains the beginning of the reserved words array.
0x0 0x6 0x0 0x190 0xa // Register 6 contains the beginning of the reserved symbols array.
0x0 0x7 0x0 0x0 0x0 0x7fffffff 0x2 0x0a // Register 7 contains the symbol used to designate an empty memory address
0x0 0x8 0x0 0x0 0xa // Register 8 contains the value which we set allocated registers to by default.

// Registers reserved for use by the memory allocator.
0x0 0xe 0x0 0x0 0xa // Register 14 is the register used to store the register that the memory allocator is current looking at.
0x0 0xf 0x0 0x0 0xa // Register 15 is the register used to store the number of consecutive registers that the memory allocator terms 'valid'.

// Type variables
// Arrays follow the following format in memory: ARRAY_SYMBOL ARRAY_TYPE_SYMBOL DATA_1 DATA_2 ... DATA_N, where ARRAY_TYPE_SYMBOL is an INTEGER_SYMBOL, CHAR_SYMBOL, etc.
0x0 0x10 0x0 0x0 0x0 0x7ffffffe 0x02 0x0a // Register 16 contains the symbol indicating that the next memory blocks are an array.
0x0 0x11 0x0 0x0 0x0 0x7ffffffd 0x02 0x0a // Register 17 contains the symbol indicating that the next memory block are an integer.
0x0 0x12 0x0 0x0 0x0 0x7ffffffc 0x02 0x0a // Register 18 contains the symbol indicating that the next memory block is a character.
0x0 0x13 0x0 0x0 0x0 0x7ffffffb 0x02 0x0a // Register 19 contains the symbol indicating the end of an array.

//Some functions used in the program

// FUNCTION 0: REQUEST MEMORY
// ACCEPTS ONE ARGUMENT: ARG 1 = SIZE OF MEMORY BLOCKS REQUESTED
// RETURNS: THE ADDRESS AT THE BEGINNING OF THE ALLOCATED MEMORY BLOCK
0x0 0x0 0x0 0x1 0x1e // Declares a function, 0, which allocates memory to caller functions
    // Initialize registers 14 and 15.
    0x0 0xe 0x0 0x1 0x9 0xa // Sets register 14 to the first publicly available register.
    0x0 0xf 0x0 0x0 0xa // Sets register 15 to 0.
    // We declare the outer loop: we will continue iterating until register 15 is equal to size.
    0x0 0x0 0x14 // Sets a marker, 0
        // Increment register 14 by one
        0x0 0xe // Literal 14
        0x0 0xe 0x9 0x0 0x1 0x1 // Add one
        0xa // Store register[14] + 1 -> register[14].
        // If &register[14] == EMPTY, increment the size of both registers 14 and 15.
        0x0 0xe 0x9 0x9 // Load the most recently selected register's value
        0x0 0x7 0x9 // EMPTY_MEMORY symbol
        0x10 // Assert equality
        0x13 // If &register[14] == EMPTY
            0x0 0xf // Literal 15
            0x0 0xf 0x9 0x0 0x1 0x1 // Add one to register[15]'s current value
            0xa // Store register[15] + 1 -> register[15].
        0x8 // End if
        // If &register[14] != EMPTY, reset register 15 to 0
        0x0 0xe 0x9 0x9 // Load the most recently selected register's value
        0x0 0x7 0x9 // EMPTY_MEMORY symbol
        0x10 0xf // Assert inequality
        0x13 // If &register[14] != EMPTY
            0x0 0xf 0x0 0x0 0xa // Store 0 to register 15.
        0x8 // End if
        // If register[15] == requested size, then we return the register. Otherwise, we will jump to marker 0.
        0x0 0xf 0x9 // Load register 15, the number of sequential registers.
        0x0 0x1 0x0 0xb 0x1f // Load first parameter's value
        0x10 // Assert equality
        0x13 // If register[15] == ARG 1
            0x0 0xe 0x9 // Load value of register 14
            0x0 0x1 0x0 0xb 0x1f // Load first parameter's value
            0x2 // Subtract
            0x0 0x1 0x1 // Add one
            0x21 0x21 // Duplicate on the stack twice so we have ADDY, ADDY, ADDY
            0x0 0x1 0x0 0xb 0x1f 0x1 // Add the size of the requested array so we get ADDY , ADDY, (ADDY + SIZE)
            0x0 0x1 0x2 // Subtract one, yielding ADDY, ADDY, (ADDY + SIZE - 1)
            0x0 0x8 0x9 // Load the default NON_EMPTY value, yielding ADDY, ADDy, (ADDY + SIZE - 1), NON_EMPTY
            0x0 0x13 0x1f // Set ADDY thru (ADDY + SIZE - 1) to NON_EMPTY, yielding a stack of just ADDY
            0x20 // Return the value of register 14
        0x8 // End if
    0x0 0x0 0x15 // Jump back to marker 0.
0x8 // End function


// FUNCTION 1: FREES MEMORY
// ACCEPTS TWO ARGUMENTS: ARG 1 = MEMORY ADDRESS TO BE FREED, ARG 2 = NUMBER OF BLOCKS TO FREE
0x0 0x1 0x0 0x2 0x1e // Declares a function, 1, which takes no arguments and prints Test: (valOfReg[1])
    0x0 0x1 0x0 0xb 0x1f // Load the value of the first parameter
    0x21 // Duplicate on stack [P(1), P(1)].
    0x0 0x2 0x0 0xb 0x1f 0x1 // Add parameter two's value to parameter one's value [P(1), P(1) + P(2)]
    0x0 0x1 0x2 // Subtract one [P(1), P(1) + P(2) - 1]
    0x0 0x7 0x9 // Get the EMPTY_MEMORY symbol
    0x0 0x13 0x1f // Set all values in the range of [P(1), P(1) + P(2) - 1] to EMPTY_MEMORY symbol
0x8 // End function

// FUNCTION 2: INCREMENTS VALUE OF "CURRENT REGISTER" REGISTER
0x0 0x2 0x0 0x0 0x1e // Declares a function, 2, which takes no arguments and increments the register indicating which register should be used next.
    0x0 0x0 // Literal 0
    0x0 0x0 0x9 // Load register 0
    0x0 0x1 // Literal 1
    0x1 // Add 1 to register 0s value
    0x0a // Store value in registers
0x8 // End function

// FUNCTION 3: GETS THE "CURRENT REGISTER" FOR PROGRAMS TO ACCESS
0x0 0x3 0x0 0x0 0x1e // Declares a function, 3, which takes no arguments and pushes the register value of the current register.
    0x0 0x0 0x9 // Read register 0
    0x20 // Return the value of register 0
0x8 // End function

// Function 4: RETURNS THE "CURRENT REGISTER" AND THEN UPDATES IT
0x0 0x4 0x0 0x0 0x1e // Declares a function, 4, which takes no arguments and pushes the register value of the current register and then updates it.
    0x0 0x2 0x1f // Update the value of the CURRENT REGISTER
    0x0 0x3 0x1f // Get the value of the CURRENT REGISTER
    0x0 0x1 // Literal 1
    0x2 // Subtract
    0x20 // Return the value of register 0
0x8 // End function

// Function 5: RETURNS THE "CURRENT" ARGUMENT FUNCTIONS REGISTER
0x0 0x5 0x0 0x0 0x1e // Declares a function, 5, which takes no arguments and returns register 3 + register 4.
    0x0 0x3 0x9 // Loads register 3
    0x0 0x4 0x9 // Loads register 4
    0x1 // Adds together
    0x20 // Return the value of register 3 + register 4;
0x8 // End function

// Function 6: RETURNS THE CURRENT ARGUMENT REGISTER, OFFSET BY A SPECIFIED VALUE (used by functions to find the beginning of their argument stack).
0x0 0x6 0x0 0x1 0x1e // Declares a function, 6, which takes one argument, the number of arguments accepted by the function, and returns function 5 minus that quantity.
    0x0 0x5 0x1f // Load the "CURRENT ARGUMENT" value
    0x0 0x2 0x2 // Subtract two
    0x21 // Duplicate on the stack
    0x9 // Read the value -- this is the argument passed by the function
    0x2 // Subtract from the first retrieved value
    0x0 0x1 0x2 // Subtract 1
    0x20 // Return ("current argument" - passed argument) - 1.
0x8 // End function

// Function 7: FREES UP A REGISTER AT AN INDICATED ADDRESS
// CURRENTLY UNIMPLEMNTED.
0x0 0x7 0x0 0x1 0x1e // Declares a function, 7, which takes one argument (a memory address) and frees it.
0x8


// FUNCTION 8: TAKES AN OBJECT TYPE AND A VALUE AND RETURNS THE POINTER TO THE MEMORY ADDRESS
0x0 0x8 0x0 0x2 0x1e // Declares a function, 8, which takes two arguments and returns a pointer to the created object.
    0x0 0x4 0x1f // Grabs the current register we can write to + increments it
    0x0 0x1 0x0 0x6 0x1f // Grabs the first parameter
    0x9 0x9 0xa // Reads the value of the register and then pushes it to the memory address
    0x0 0x4 0x1f // Grabs the current register we can write to + increments it
    0x0 0x2 0x0 0x6 0x1f // Grabs the second parameter
    0x9 0xa // Reads the value of the register and then pushes it to the memory address
    0x0 0x3 0x1f 0x0 0x2 0x2 // Subtract two from the register value so we are back at where the pointer should point.
    0x20 // Return
0x8 // End function

// Function 9: PRINTS THE RAW VALUE STORED AT THE REGISTER INDICATED BY THE FIRST ARGUMENT (INTEGER REPRESENTATION)
0x0 0x9 0x0 0x1 0x1e // Declares a function, 9, which takes one argument and prints it.
    0x0 0x1 0x0 0x6 0x1f // Get the first parameter
    0x9 // Load the value that this is pointing to.
    0x0 0x1 0x1 // Move past the type declaration to the actual data.
    0x9 // Get the value of this cell
    0x7 // Print
0x8 // End function

// Function 10: PRINTS AN ARRAY
// TAKES ONE ARGUMENT: 1) A POINTER TO THE BEGINNING OF THE ARRAY
// Printing is done by iterating over every memory address and then reading, which pushes them to the stack, followed by calling PRINT_LONG.
0x0 0xa 0x0 0x1 0x1e // Declares a function, 10, which takes one argument and prints the array at that address.
    0x0 0x3 0x1f // Load current register id
    0x0 0x1 0x0 0xb 0x1f // Get parameter one's value
    0x21 // Duplicate
    0x0 0xc 0x1f // Get array length
    0x0 0x1 0x1 // Add one to array length to compensate for metadata.
    0x1 // Add this length to the beginning index.
    0xa // Store this value in the current register
    0x0 0xa 0x14 // Set a marker, 10
        0x0 0x3 0x1f 0x9 0x9 // Load value of current register, pushes the array's contents to the stack at this position
        0x0 0x3 0x1f // Load the id of the current register
        0x0 0x3 0x1f 0x9 // Load the value of the current register
        0x0 0x1 0x2 0xa // Subtract one and store in register
        0x0 0x3 0x1f 0x9 // Load the value of the current register (which is now one less than before)
        0x0 0x1 0x0 0xb 0x1f // Get parameter one's value
        0x0 0x1 0x1 // Add one (to bring us to the type declaration of the array)
        0x10 // Assert equality
        0x13 // Check if previous statement is true
            0x0 0x1 0x0 0xb 0x1f // Get parameter one's value
            0x0 0xc 0x1f // Get array length
            0x23 // Print out the last ARRAY_LENGTH chars
            0x22 // VOID_RETURN
        0x8 // End If
    0x0 0xa 0x15 // Jump to 10
0x8 //End function


// Function 11: LOADS THE VALUE SPECIFIED BY FUNCTION 6; IE: RETURNS THE VALUE OF A SPECIFIED ARGUMENT
// GET VALUE OF ARGUMENT a.
// DOES TWO CALCULATIONS TO SHIFT REGISTERS SO IT CAN READ AS IF IT WERE THE PROGRAM, AND THEN RETURNS THE VALUE, NOT POINTER, OF THE ARGUMENT, SAVING A READ CALL IN CALLER FUNCTION.
// TAKES ONE ARGUMENT: ARGUMENT NUMBER (0 index).
0x0 0x0b 0x0 0x1 0x1e // Declares a function, 11, which takes one argument and returns the value of the memory address returned by function 6.
    0x0 0x1 0x0 0x6 0x1f // Get the first parameter's memory address
    0x0 0x1 0x0 0x6 0x1f // Get the first parameter
    0x9 // Load first parameter
    0x0 0x1 0x1 // Add one so we can shift left an additional step -- we should now be where the function would call function 6 itself
    0x2 // Subtract to bring us to the correct pointer
    0x9 // Load the value
    0x20 // Return
0x8 // End function

// FUNCTION 12: GET ARRAY LENGTH
// TAKES ONE ARGUMENT, AN ARRAY, AND RETURNS ITS LENGTH
0x0 0x0c 0x0 0x1 0x1e // Declares a function, 12, which takes an array as an argument and returns its length
    0x0 0x1 0x0 0xb 0x1f // Get the pointer to the beginning of the array
    0x0 0x2 0x1 // Add two so we are at the beginning of the data
    0x0 0xc 0x14 // Set a marker, 12.
        0x21 // Duplicate the current register we're evaluating on the stack
        0x9 // Read data in the current register (array content)
        0x0 0x13 0x9 // Load end of array symbol
        0x10 // Check the data in the array is the end of array symbol.
        0x13 // Check if we are at the end of the array
            0x0 0x1 0x0 0xb // Get the first argument's value
            0x1f // Get the pointer to the beginning of the array
            0x0 0x2 0x1 // Add two so that we get (final - (original + 2)) to offset the two spaces we skipped.
            0x2 // Subtract
            0x20 // Return this value.
        0x8 // End if statement
        0x0 0x1 0x1 // Add one to the register
    0x0 0xc 0x15 // Jump back to mark 12.
0x8 // End function

// FUNCTION 13: PUSH OBJECT TO CURRENT REGISTER
// TAKES ONE ARGUMENT, THE OBJECT TO PUSH, AND RETURNS THE REGISTER IT WAS PUSHED TO.
0x0 0x0d 0x0 0x1 0x1e // Declares a function, 13, which takes one parameter
    0x0 0x3 0x1f // Load current register
    0x0 0x1 0x0 0xb 0x1f // Get parameter passed in
    0xa // Store to register
    0x0 0x3 0x1f // Reload the current register for returning purposes.
    0x20 // Return
0x8 // End function

// FUNCTION 14: CREATES AN ARRAY
// TAKES THREE ARGUMENTS: THE STARTING REGISTER, THE SIZE OF THE ARRAY, AND THE TYPE OF OBJECTS IN THE ARRAY
0x0 0x0e 0x0 0x3 0x1e // Declares a function, 14, which takes three parameters
    // Indicate that this is an array
        0x0 0x1 0x0 0xb 0x1f // Load first parameter
        0x0 0x10 0x9 // Load the ARRAY_SYMBOL
        0xa // Push the array symbol to the first register
    // Add the type declaration
        0x0 0x1 0x0 0xb 0x1f // Load first parameter
        0x0 0x1 0x1 // Move one to the right
        0x0 0x3 0x0 0xb 0x1f // Load third parameter
        0xa // Push the type to the array to the register
    // Jump to the end of the array
        0x0 0x1 0x0 0xb 0x1f // Load first parameter
        0x0 0x2 0x0 0xb 0x1f // Load second parameter
        0x1 // Add them together
        0x0 0x2 0x1 // Add two more to push to the end of the array
        0x0 0x13 0x9 // Load the end of array symbol
        0xa // Push the end of array symbol onto the register
    // Update the current instruction IFF we are going past the current instruction
        0x0 0x0 0x9 // Get the current instruction number
        0x0 0x1 0x0 0xb 0x1f // Load first parameter
        0x0 0x2 0x0 0xb 0x1f // Load second parameter
        0x1 // Add them together
        0x0 0x3 0x1 // Add three more to push to the next free instruction
        0x12 // Assert that a is less than b
        0x13 // If the current instruction is less than the new instruction
            0x0 0x0 // Literal 0
            0x0 0x1 0x0 0xb 0x1f // Load first parameter
            0x0 0x2 0x0 0xb 0x1f // Load second parameter
            0x1 // Add them together
            0x0 0x3 0x1 // Add three more to push to the next free instruction
            0xa // Set to the next instruction
        0x8 // End if
0x8 // End function

// FUNCTION 15: INSERTS A VALUE, ARG 3, IN AN ARRAY STARTING AT ARG 1, IN POSITION ARG 2.
0x0 0x0f 0x0 0x3 0x1e // Declares a function, 15, which takes three parameters.
    0x0 0x1 0x0 0xb 0x1f // Load first parameter
    0x0 0x2 0x0 0xb 0x1f // Load second parameter
    0x1 // Add
    0x0 0x2 0x1 // Add 2 to offset the first two data registers.
    0x0 0x3 0x0 0xb 0x1f // Load third parameter
    0xa // Push
0x8 // End function

// FUNCTION 16: Returns the value of position ARG 2 of array beginning at ARG 1.
0x0 0x10 0x0 0x2 0x1e // Declares a function, 16, which takes two parameters
    0x0 0x1 0x0 0xb 0x1f // Load first parameter
    0x0 0x2 0x0 0xb 0x1f // Load second parameter
    0x1 // Add
    0x0 0x2 0x1 // Add 2 to offset the first two data registers.
    0x9 // Load the value of the register
    0x20 // Return this value
0x8 // End function

// FUNCTION 17: COMPARES TWO CHAR ARRAYS AND RETURNS TRUE IF THEY ARE EQUAL, FALSE OTHERWISE
// TAKES TWO ARGS, EACH BEING A POINTER TO THE CHAR ARRAY.
0x0 0x11 0x0 0x2 0x1e // Declares a function, 17, which takes two parameters
    0x0 0x1 0x0 0xb 0x1f // Load first parameter's value
    0x0 0xc 0x1f // Get length of array 1
    0x0 0x2 0x0 0xb 0x1f // Load second parameter's value
    0x0 0xc 0x1f // Get length of array 2
    0x10 0x0f // Check if they are not equal
    0x13 // If the lengths are not equal
        0x0 0x0 0x20 // Return false
    0x8 // End if
    0x0 0x3 0x1f // Get the current register
    0x0 0x1 0x0 0xb 0x1f // Load first parameter's value
    0x0 0xc 0x1f // Get length of array 1
    0x0 0x1 0x2 // Subtract 1 since length isn't zero indexed.
    0xa // Store the length in the current register
    0x0 0x11 0x14 // Set a marker, 17
        0x0 0x1 0x0 0xb 0x1f // Load first parameter's value
        0x21 // Duplicate
        0x0 0x3 0x1f 0x9 // Get current character number
        0x0 0x10 0x1f // Get the current character from the array
        0x0 0x2 0x0 0xb 0x1f // Load second parameter's value
        0x0 0x3 0x1f 0x9 // Get current character number
        0x0 0x10 0x1f // Get the current character from the array
        0x10 0x0f // Check if not equal
        0x13 // If arr1[x] != arr2[x]
            0x0 0x0 0x20 // Return 0 -- false
        0x8 // End if
        0x0 0x3 0x1f 0x9 // Get current register's value (current count)
        0x0 0x0 0x10 // Check if current register is 0
        0x13 // If current register == 0
            0x0 0x1 0x20 // Return true
        0x8 // End if

        0x0 0x3 0x1f // Get current register
        0x0 0x3 0x1f 0x9 // Get current register's value (current count)
        0x0 0x1 0x2 // Subtract one
        0xa // Store in the register
    0x0 0x11 0x15 // Jump to marker 17
0x8 // End function

// FUNCTION 18: SUBSTRING
// TAKES THREE ARGUMENTS: ARG 1 = POINTER TO ARRAY, ARG 2 =
0x0 0x12 0x0 0x3 0x1e //
    0x0 0x0
0x8 // End if

// FUNCTION 19: SET ALL REGISTERS IN RANGE TO VALUE
// TAKES THREE ARGUMENTS: ARG 1 = BEGINNING REGISTER, ARG 2 = END REGISTER, ARG 3 = VALUE TO SET TO
0x0 0x13 0x0 0x3 0x1e // Declares a function, 19, which takes 3 parameters.
    0x0 0x13 0x14 // Sets a marker, 19
        0x0 0x1 0x0 0xb 0x1f // Get the first parameter
        0x0 0x2 0x0 0xb 0x1f // Get the second parameter
        0x11 // Assert p(1) > p(2)
        0x13 // If p(1) > p(2)
            0x22 // Return void
        0x8 // End if
        0x0 0x1 0x0 0xb 0x1f // Get the the first parameter
        0x0 0x3 0x0 0xb 0x1f // Get the third parameter
        0xa // Store p(3) -> &p(1)
        0x0 0x1 0x0 0x6 0x1f // Get the first parameter's memory address
        0x21 0x9 // Get the first parameter's value
        0x0 0x1 0x1 // Add one
        0xa // Store p(1) + 1 -> p(1).
    0x0 0x13 0x15 // Jump to marker 19
0x8

// **C*O*M*P*I*L*E*R*     *V*A*R*I*A*B*L*E*S** //
// **C*O*M*P*I*L*E*R*     *V*A*R*I*A*B*L*E*S** //

// Form the reserved words array
0x0 0x5 0x9 // Load in the memory address we can form the array at
0x0 0x8 // Create an array of size 8
0x0 0x11 0x9 // Load the Integer type so we can specify that this is an integer array
0x0 0x0e 0x1f // Create an integer array of size 8
0x0 0x5 0x9 // Load in the memory address we can form the array at

// Form the reserved word: LET (reserved[0]).
0x0 0x5 0x9 // Load in the memory address of the reserved words array
0x0 0x0 // Literal 0
0x0 0x3 0x1f // Get the current register + increase it
0x0 0xf 0x1f // Load the pointer address of the word "LET" into the reserved words array at pos 0.
//Creates the word's array
0x0 0x5 0x9 // Load in the memory address of the reserved words array
0x0 0x0 // Literal 0
0x0 0x10 0x1f // Get address of the word "LET"
0x0 0x3 // Create an array of size 3
0x0 0x12 0x9 // Load the Character type so we can specify that this is an Character array
0x0 0x0e 0x1f // Create an Character array of size 3
//Forms individual characters of the word
0x0 0x5 0x9 0x0 0x0 0x0 0x10 0x1f // Load the address of the word "LET"
0x0 0x0 // Position 0
0x0 0x1 0x0 0xb 0x1c // The letter "L"
0x0 0xf 0x1f
0x0 0x5 0x9 0x0 0x0 0x0 0x10 0x1f // Load the address of the word "LET"
0x0 0x1 // Position 1
0x0 0x1 0x0 0x4 0x1c // The letter "E"
0x0 0xf 0x1f
0x0 0x5 0x9 0x0 0x0 0x0 0x10 0x1f // Load the address of the word "LET"
0x0 0x2 // Position 2
0x0 0x1 0x0 0x13 0x1c // The letter "T"
0x0 0xf 0x1f

// Form the reserved word: FUN (reserved[1]).
0x0 0x5 0x9 // Load in the memory address of the reserved words array
0x0 0x1 // Literal 1
0x0 0x3 0x1f // Get the current register + increase it
0x0 0xf 0x1f // Load the pointer address of the word "FUN" into the reserved words array at pos 1.
//Creates the word's array
0x0 0x5 0x9 // Load in the memory address of the reserved words array
0x0 0x1 // Literal 1
0x0 0x10 0x1f // Get address of the word "FUN"
0x0 0x3 // Create an array of size 3
0x0 0x12 0x9 // Load the Character type so we can specify that this is an Character array
0x0 0x0e 0x1f // Create an Character array of size 3
//Forms individual characters of the word
0x0 0x5 0x9 0x0 0x1 0x0 0x10 0x1f // Load the address of the word "FUN"
0x0 0x0 // Position 0
0x0 0x1 0x0 0x5 0x1c // The letter "F"
0x0 0xf 0x1f
0x0 0x5 0x9 0x0 0x1 0x0 0x10 0x1f // Load the address of the word "FUN"
0x0 0x1 // Position 1
0x0 0x1 0x0 0x14 0x1c // The letter "U"
0x0 0xf 0x1f
0x0 0x5 0x9 0x0 0x1 0x0 0x10 0x1f // Load the address of the word "FUN"
0x0 0x2 // Position 2
0x0 0x1 0x0 0xd 0x1c // The letter "N"
0x0 0xf 0x1f

// Form the reserved word: REP (reserved[2]).
0x0 0x5 0x9 // Load in the memory address of the reserved words array
0x0 0x2 // Literal 2
0x0 0x3 0x1f // Get the current register + increase it
0x0 0xf 0x1f // Load the pointer address of the word "REP" into the reserved words array at pos 1.
//Creates the word's array
0x0 0x5 0x9 // Load in the memory address of the reserved words array
0x0 0x2 // Literal 2
0x0 0x10 0x1f // Get address of the word "REP"
0x0 0x3 // Create an array of size 3
0x0 0x12 0x9 // Load the Character type so we can specify that this is an Character array
0x0 0x0e 0x1f // Create an Character array of size 3
//Forms individual characters of the word
0x0 0x5 0x9 0x0 0x2 0x0 0x10 0x1f // Load the address of the word "REP"
0x0 0x0 // Position 0
0x0 0x1 0x0 0x11 0x1c // The letter "R"
0x0 0xf 0x1f
0x0 0x5 0x9 0x0 0x2 0x0 0x10 0x1f // Load the address of the word "REP"
0x0 0x1 // Position 1
0x0 0x1 0x0 0x4 0x1c // The letter "E"
0x0 0xf 0x1f
0x0 0x5 0x9 0x0 0x2 0x0 0x10 0x1f // Load the address of the word "REP"
0x0 0x2 // Position 2
0x0 0x1 0x0 0xf 0x1c // The letter "P"
0x0 0xf 0x1f

// Form the reserved word: FOR (reserved[3]).
0x0 0x5 0x9 // Load in the memory address of the reserved words array
0x0 0x3 // Literal 3
0x0 0x3 0x1f // Get the current register + increase it
0x0 0xf 0x1f // Load the pointer address of the word "FOR" into the reserved words array at pos 1.
//Creates the word's array
0x0 0x5 0x9 // Load in the memory address of the reserved words array
0x0 0x3 // Literal 3
0x0 0x10 0x1f // Get address of the word "FOR"
0x0 0x3 // Create an array of size 3
0x0 0x12 0x9 // Load the Character type so we can specify that this is an Character array
0x0 0x0e 0x1f // Create an Character array of size 3
//Forms individual characters of the word
0x0 0x5 0x9 0x0 0x3 0x0 0x10 0x1f // Load the address of the word "FOR"
0x0 0x0 // Position 0
0x0 0x1 0x0 0x5 0x1c // The letter "F"
0x0 0xf 0x1f
0x0 0x5 0x9 0x0 0x3 0x0 0x10 0x1f // Load the address of the word "FOR"
0x0 0x1 // Position 1
0x0 0x1 0x0 0xe 0x1c // The letter "O"
0x0 0xf 0x1f
0x0 0x5 0x9 0x0 0x3 0x0 0x10 0x1f // Load the address of the word "FOR"
0x0 0x2 // Position 2
0x0 0x1 0x0 0x11 0x1c // The letter "R"
0x0 0xf 0x1f

// Form the reserved word: MAY (reserved[4]).
0x0 0x5 0x9 // Load in the memory address of the reserved words array
0x0 0x4 // Literal 4
0x0 0x3 0x1f // Get the current register + increase it
0x0 0xf 0x1f // Load the pointer address of the word "MAY" into the reserved words array at pos 1.
//Creates the word's array
0x0 0x5 0x9 // Load in the memory address of the reserved words array
0x0 0x4 // Literal 4
0x0 0x10 0x1f // Get address of the word "MAY"
0x0 0x3 // Create an array of size 3
0x0 0x12 0x9 // Load the Character type so we can specify that this is an Character array
0x0 0x0e 0x1f // Create an Character array of size 3
//Forms individual characters of the word
0x0 0x5 0x9 0x0 0x4 0x0 0x10 0x1f // Load the address of the word "MAY"
0x0 0x0 // Position 0
0x0 0x1 0x0 0xc 0x1c // The letter "M"
0x0 0xf 0x1f
0x0 0x5 0x9 0x0 0x4 0x0 0x10 0x1f // Load the address of the word "MAY"
0x0 0x1 // Position 1
0x0 0x1 0x0 0x0 0x1c // The letter "A"
0x0 0xf 0x1f
0x0 0x5 0x9 0x0 0x4 0x0 0x10 0x1f // Load the address of the word "MAY"
0x0 0x2 // Position 2
0x0 0x1 0x0 0x18 0x1c // The letter "Y"
0x0 0xf 0x1f

// Form the reserved word: ELF (reserved[5]).
0x0 0x5 0x9 // Load in the memory address of the reserved words array
0x0 0x5 // Literal 5
0x0 0x3 0x1f // Get the current register + increase it
0x0 0xf 0x1f // Load the pointer address of the word "ELF" into the reserved words array at pos 1.
//Creates the word's array
0x0 0x5 0x9 // Load in the memory address of the reserved words array
0x0 0x5 // Literal 5
0x0 0x10 0x1f // Get address of the word "ELF"
0x0 0x3 // Create an array of size 3
0x0 0x12 0x9 // Load the Character type so we can specify that this is an Character array
0x0 0x0e 0x1f // Create an Character array of size 3
//Forms individual characters of the word
0x0 0x5 0x9 0x0 0x5 0x0 0x10 0x1f // Load the address of the word "ELF"
0x0 0x0 // Position 0
0x0 0x1 0x0 0x4 0x1c // The letter "E"
0x0 0xf 0x1f
0x0 0x5 0x9 0x0 0x5 0x0 0x10 0x1f // Load the address of the word "ELF"
0x0 0x1 // Position 1
0x0 0x1 0x0 0xb 0x1c // The letter "L"
0x0 0xf 0x1f
0x0 0x5 0x9 0x0 0x5 0x0 0x10 0x1f // Load the address of the word "ELF"
0x0 0x2 // Position 2
0x0 0x1 0x0 0x5 0x1c // The letter "F"
0x0 0xf 0x1f

// Form the reserved word: ELS (reserved[6]).
0x0 0x5 0x9 // Load in the memory address of the reserved words array
0x0 0x6 // Literal 6
0x0 0x3 0x1f // Get the current register + increase it
0x0 0xf 0x1f // Load the pointer address of the word "ELS" into the reserved words array at pos 1.
//Creates the word's array
0x0 0x5 0x9 // Load in the memory address of the reserved words array
0x0 0x6 // Literal 6
0x0 0x10 0x1f // Get address of the word "ELS"
0x0 0x3 // Create an array of size 3
0x0 0x12 0x9 // Load the Character type so we can specify that this is an Character array
0x0 0x0e 0x1f // Create an Character array of size 3
//Forms individual characters of the word
0x0 0x5 0x9 0x0 0x6 0x0 0x10 0x1f // Load the address of the word "ELS"
0x0 0x0 // Position 0
0x0 0x1 0x0 0x4 0x1c // The letter "E"
0x0 0xf 0x1f
0x0 0x5 0x9 0x0 0x6 0x0 0x10 0x1f // Load the address of the word "ELS"
0x0 0x1 // Position 1
0x0 0x1 0x0 0xb 0x1c // The letter "L"
0x0 0xf 0x1f
0x0 0x5 0x9 0x0 0x6 0x0 0x10 0x1f // Load the address of the word "ELS"
0x0 0x2 // Position 2
0x0 0x1 0x0 0x12 0x1c // The letter "S"
0x0 0xf 0x1f

// Form the reserved word: RET (reserved[7]).
0x0 0x5 0x9 // Load in the memory address of the reserved words array
0x0 0x7 // Literal 7
0x0 0x3 0x1f // Get the current register + increase it
0x0 0xf 0x1f // Load the pointer address of the word "RET" into the reserved words array at pos 1.
//Creates the word's array
0x0 0x5 0x9 // Load in the memory address of the reserved words array
0x0 0x7 // Literal 7
0x0 0x10 0x1f // Get address of the word "RET"
0x0 0x3 // Create an array of size 3
0x0 0x12 0x9 // Load the Character type so we can specify that this is an Character array
0x0 0x0e 0x1f // Create an Character array of size 3
//Forms individual characters of the word
0x0 0x5 0x9 0x0 0x7 0x0 0x10 0x1f // Load the address of the word "RET"
0x0 0x0 // Position 0
0x0 0x1 0x0 0x11 0x1c // The letter "R"
0x0 0xf 0x1f
0x0 0x5 0x9 0x0 0x7 0x0 0x10 0x1f // Load the address of the word "RET"
0x0 0x1 // Position 1
0x0 0x1 0x0 0x4 0x1c // The letter "E"
0x0 0xf 0x1f
0x0 0x5 0x9 0x0 0x7 0x0 0x10 0x1f // Load the address of the word "RET"
0x0 0x2 // Position 2
0x0 0x1 0x0 0x13 0x1c // The letter "T"
0x0 0xf 0x1f

0x0 0x5 0x9 0x0 0x0 0x0 0x10 0x1f 0x 0xa 0x1f // Print the word "LET"
0x0 0x5 0x9 0x0 0x1 0x0 0x10 0x1f 0x 0xa 0x1f // Print the word "FUN"
0x0 0x5 0x9 0x0 0x2 0x0 0x10 0x1f 0x 0xa 0x1f // Print the word "REP"
0x0 0x5 0x9 0x0 0x3 0x0 0x10 0x1f 0x 0xa 0x1f // Print the word "FOR"
0x0 0x5 0x9 0x0 0x4 0x0 0x10 0x1f 0x 0xa 0x1f // Print the word "MAY"
0x0 0x5 0x9 0x0 0x5 0x0 0x10 0x1f 0x 0xa 0x1f // Print the word "ELF"
0x0 0x5 0x9 0x0 0x6 0x0 0x10 0x1f 0x 0xa 0x1f // Print the word "ELS"
0x0 0x5 0x9 0x0 0x7 0x0 0x10 0x1f 0x 0xa 0x1f // Print the word "RET"

// Form the reserved symbols array
0x0 0x5 0x9 0x0 0x0


0x0 0x5 0x9 0x0 0x0 0x0 0x10 0x1f
0x0 0x5 0x9 0x0 0x0 0x0 0x10 0x1f
0x0 0x11 0x1f 0x7

// Request a block of memory and then free it
0x0 0x9 0x0 0x0 0x1f // Request 9 blocks of memory
0x21 0x7 // Print the addy
0x0 0x9 0x0 0x1 0x1f // Free 9 blocks of memory starting at the requested addy
0x25

// Load a text document into memory
0x0 0x3 0x1f // Get the "CURRENT REGISTER" // Will be used for later reference.
0x0 0x80 // Literal 128
0x0 0x4 0x1f // Get the "CURRENT REGISTER"
0x1d // Load file into memory
0x0 0xa 0x1f // Print the entire array of characters.
